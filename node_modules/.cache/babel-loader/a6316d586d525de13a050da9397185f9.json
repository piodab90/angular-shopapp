{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nexport function find(predicate, thisArg) {\n  if (typeof predicate !== 'function') {\n    throw new TypeError('predicate is not a function');\n  }\n\n  return source => source.lift(new FindValueOperator(predicate, source, false, thisArg));\n}\nexport class FindValueOperator {\n  constructor(predicate, source, yieldIndex, thisArg) {\n    this.predicate = predicate;\n    this.source = source;\n    this.yieldIndex = yieldIndex;\n    this.thisArg = thisArg;\n  }\n\n  call(observer, source) {\n    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n  }\n\n}\nexport class FindValueSubscriber extends Subscriber {\n  constructor(destination, predicate, source, yieldIndex, thisArg) {\n    super(destination);\n    this.predicate = predicate;\n    this.source = source;\n    this.yieldIndex = yieldIndex;\n    this.thisArg = thisArg;\n    this.index = 0;\n  }\n\n  notifyComplete(value) {\n    const destination = this.destination;\n    destination.next(value);\n    destination.complete();\n    this.unsubscribe();\n  }\n\n  _next(value) {\n    const {\n      predicate,\n      thisArg\n    } = this;\n    const index = this.index++;\n\n    try {\n      const result = predicate.call(thisArg || this, value, index, this.source);\n\n      if (result) {\n        this.notifyComplete(this.yieldIndex ? index : value);\n      }\n    } catch (err) {\n      this.destination.error(err);\n    }\n  }\n\n  _complete() {\n    this.notifyComplete(this.yieldIndex ? -1 : undefined);\n  }\n\n}","map":{"version":3,"sources":["../../../src/internal/operators/find.ts"],"names":[],"mappings":"AAEA,SAAQ,UAAR,QAAyB,eAAzB;AA8CA,OAAM,SAAU,IAAV,CAAkB,SAAlB,EACkB,OADlB,EAC+B;AACnC,MAAI,OAAO,SAAP,KAAqB,UAAzB,EAAqC;AACnC,UAAM,IAAI,SAAJ,CAAc,6BAAd,CAAN;AACD;;AACD,SAAQ,MAAD,IAA2B,MAAM,CAAC,IAAP,CAAY,IAAI,iBAAJ,CAAsB,SAAtB,EAAiC,MAAjC,EAAyC,KAAzC,EAAgD,OAAhD,CAAZ,CAAlC;AACD;AAED,OAAM,MAAO,iBAAP,CAAwB;AAC5B,EAAA,WAAA,CAAoB,SAApB,EACoB,MADpB,EAEoB,UAFpB,EAGoB,OAHpB,EAGiC;AAHb,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACnB;;AAED,EAAA,IAAI,CAAC,QAAD,EAA0B,MAA1B,EAAqC;AACvC,WAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,mBAAJ,CAAwB,QAAxB,EAAkC,KAAK,SAAvC,EAAkD,KAAK,MAAvD,EAA+D,KAAK,UAApE,EAAgF,KAAK,OAArF,CAAjB,CAAP;AACD;;AAT2B;AAiB9B,OAAM,MAAO,mBAAP,SAAsC,UAAtC,CAAmD;AAGvD,EAAA,WAAA,CAAY,WAAZ,EACoB,SADpB,EAEoB,MAFpB,EAGoB,UAHpB,EAIoB,OAJpB,EAIiC;AAC/B,UAAM,WAAN;AAJkB,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,OAAA,GAAA,OAAA;AANZ,SAAA,KAAA,GAAgB,CAAhB;AAQP;;AAEO,EAAA,cAAc,CAAC,KAAD,EAAW;AAC/B,UAAM,WAAW,GAAG,KAAK,WAAzB;AAEA,IAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;AACA,IAAA,WAAW,CAAC,QAAZ;AACA,SAAK,WAAL;AACD;;AAES,EAAA,KAAK,CAAC,KAAD,EAAS;AACtB,UAAM;AAAC,MAAA,SAAD;AAAY,MAAA;AAAZ,QAAuB,IAA7B;AACA,UAAM,KAAK,GAAG,KAAK,KAAL,EAAd;;AACA,QAAI;AACF,YAAM,MAAM,GAAG,SAAS,CAAC,IAAV,CAAe,OAAO,IAAI,IAA1B,EAAgC,KAAhC,EAAuC,KAAvC,EAA8C,KAAK,MAAnD,CAAf;;AACA,UAAI,MAAJ,EAAY;AACV,aAAK,cAAL,CAAoB,KAAK,UAAL,GAAkB,KAAlB,GAA0B,KAA9C;AACD;AACF,KALD,CAKE,OAAO,GAAP,EAAY;AACZ,WAAK,WAAL,CAAiB,KAAjB,CAAuB,GAAvB;AACD;AACF;;AAES,EAAA,SAAS,GAAA;AACjB,SAAK,cAAL,CAAoB,KAAK,UAAL,GAAkB,CAAC,CAAnB,GAAuB,SAA3C;AACD;;AAlCsD","sourcesContent":["import { Subscriber } from '../Subscriber';\nexport function find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return (source) => source.lift(new FindValueOperator(predicate, source, false, thisArg));\n}\nexport class FindValueOperator {\n    constructor(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    call(observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    }\n}\nexport class FindValueSubscriber extends Subscriber {\n    constructor(destination, predicate, source, yieldIndex, thisArg) {\n        super(destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    notifyComplete(value) {\n        const destination = this.destination;\n        destination.next(value);\n        destination.complete();\n        this.unsubscribe();\n    }\n    _next(value) {\n        const { predicate, thisArg } = this;\n        const index = this.index++;\n        try {\n            const result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    }\n    _complete() {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    }\n}\n//# sourceMappingURL=find.js.map"]},"metadata":{},"sourceType":"module"}