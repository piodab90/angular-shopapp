{"ast":null,"code":"import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n  constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n    super();\n    this.scheduler = scheduler;\n    this._events = [];\n    this._infiniteTimeWindow = false;\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  nextInfiniteTimeWindow(value) {\n    const _events = this._events;\n\n    _events.push(value);\n\n    if (_events.length > this._bufferSize) {\n      _events.shift();\n    }\n\n    super.next(value);\n  }\n\n  nextTimeWindow(value) {\n    this._events.push(new ReplayEvent(this._getNow(), value));\n\n    this._trimBufferThenGetEvents();\n\n    super.next(value);\n  }\n\n  _subscribe(subscriber) {\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow() {\n    return (this.scheduler || queue).now();\n  }\n\n  _trimBufferThenGetEvents() {\n    const now = this._getNow();\n\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = this._events;\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent {\n  constructor(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n\n}","map":{"version":3,"sources":["../../src/internal/ReplaySubject.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport class ReplaySubject extends Subject {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        const _events = this._events;\n        _events.push(value);\n        if (_events.length > this._bufferSize) {\n            _events.shift();\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n        this._trimBufferThenGetEvents();\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n//# sourceMappingURL=ReplaySubject.js.map"]},"metadata":{},"sourceType":"module"}