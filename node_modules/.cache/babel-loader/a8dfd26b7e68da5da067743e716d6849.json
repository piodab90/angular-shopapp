{"ast":null,"code":"import { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  let length = arguments.length;\n  let scheduler = async;\n\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nclass BufferTimeOperator {\n  constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  }\n\n}\n\nclass Context {\n  constructor() {\n    this.buffer = [];\n  }\n\n}\n\nclass BufferTimeSubscriber extends Subscriber {\n  constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    super(destination);\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n    this.contexts = [];\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = {\n        subscriber: this,\n        context,\n        bufferTimeSpan\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = {\n        subscriber: this,\n        context\n      };\n      const creationState = {\n        bufferTimeSpan,\n        bufferCreationInterval,\n        subscriber: this,\n        scheduler\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  _next(value) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext;\n\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n\n  _error(err) {\n    this.contexts.length = 0;\n\n    super._error(err);\n  }\n\n  _complete() {\n    const {\n      contexts,\n      destination\n    } = this;\n\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n\n    super._complete();\n  }\n\n  _unsubscribe() {\n    this.contexts = null;\n  }\n\n  onBufferFull(context) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = {\n        subscriber: this,\n        context,\n        bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  openContext() {\n    const context = new Context();\n    this.contexts.push(context);\n    return context;\n  }\n\n  closeContext(context) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n\n}\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  const subscriber = state.subscriber;\n  const prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  const {\n    bufferCreationInterval,\n    bufferTimeSpan,\n    subscriber,\n    scheduler\n  } = state;\n  const context = subscriber.openContext();\n  const action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber,\n      context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  const {\n    subscriber,\n    context\n  } = arg;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["../../../src/internal/operators/bufferTime.ts"],"names":[],"mappings":"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","sourcesContent":["import { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    let length = arguments.length;\n    let scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    let bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    let maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nclass BufferTimeOperator {\n    constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n}\nclass Context {\n    constructor() {\n        this.buffer = [];\n    }\n}\nclass BufferTimeSubscriber extends Subscriber {\n    constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        super(destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        const context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            const closeState = { subscriber: this, context };\n            const creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    _next(value) {\n        const contexts = this.contexts;\n        const len = contexts.length;\n        let filledBufferContext;\n        for (let i = 0; i < len; i++) {\n            const context = contexts[i];\n            const buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    }\n    _error(err) {\n        this.contexts.length = 0;\n        super._error(err);\n    }\n    _complete() {\n        const { contexts, destination } = this;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        super._complete();\n    }\n    _unsubscribe() {\n        this.contexts = null;\n    }\n    onBufferFull(context) {\n        this.closeContext(context);\n        const closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            const bufferTimeSpan = this.bufferTimeSpan;\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    }\n    openContext() {\n        const context = new Context();\n        this.contexts.push(context);\n        return context;\n    }\n    closeContext(context) {\n        this.destination.next(context.buffer);\n        const contexts = this.contexts;\n        const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    }\n}\nfunction dispatchBufferTimeSpanOnly(state) {\n    const subscriber = state.subscriber;\n    const prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n    const context = subscriber.openContext();\n    const action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    const { subscriber, context } = arg;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map"]},"metadata":{},"sourceType":"module"}