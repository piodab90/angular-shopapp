{"ast":null,"code":"import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  constructor(SchedulerAction = VirtualAction, maxFrames = Number.POSITIVE_INFINITY) {\n    super(SchedulerAction, () => this.frame);\n    this.maxFrames = maxFrames;\n    this.frame = 0;\n    this.index = -1;\n  }\n\n  flush() {\n    const {\n      actions,\n      maxFrames\n    } = this;\n    let error, action;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  }\n\n}\nVirtualTimeScheduler.frameTimeFactor = 10;\nexport class VirtualAction extends AsyncAction {\n  constructor(scheduler, work, index = scheduler.index += 1) {\n    super(scheduler, work);\n    this.scheduler = scheduler;\n    this.work = work;\n    this.index = index;\n    this.active = true;\n    this.index = scheduler.index = index;\n  }\n\n  schedule(state, delay = 0) {\n    if (!this.id) {\n      return super.schedule(state, delay);\n    }\n\n    this.active = false;\n    const action = new VirtualAction(this.scheduler, this.work);\n    this.add(action);\n    return action.schedule(state, delay);\n  }\n\n  requestAsyncId(scheduler, id, delay = 0) {\n    this.delay = scheduler.frame + delay;\n    const {\n      actions\n    } = scheduler;\n    actions.push(this);\n    actions.sort(VirtualAction.sortActions);\n    return true;\n  }\n\n  recycleAsyncId(scheduler, id, delay = 0) {\n    return undefined;\n  }\n\n  _execute(state, delay) {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  static sortActions(a, b) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/internal/scheduler/VirtualTimeScheduler.ts"],"names":[],"mappings":"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","sourcesContent":["import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport class VirtualTimeScheduler extends AsyncScheduler {\n    constructor(SchedulerAction = VirtualAction, maxFrames = Number.POSITIVE_INFINITY) {\n        super(SchedulerAction, () => this.frame);\n        this.maxFrames = maxFrames;\n        this.frame = 0;\n        this.index = -1;\n    }\n    flush() {\n        const { actions, maxFrames } = this;\n        let error, action;\n        while ((action = actions[0]) && action.delay <= maxFrames) {\n            actions.shift();\n            this.frame = action.delay;\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\nVirtualTimeScheduler.frameTimeFactor = 10;\nexport class VirtualAction extends AsyncAction {\n    constructor(scheduler, work, index = scheduler.index += 1) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.index = index;\n        this.active = true;\n        this.index = scheduler.index = index;\n    }\n    schedule(state, delay = 0) {\n        if (!this.id) {\n            return super.schedule(state, delay);\n        }\n        this.active = false;\n        const action = new VirtualAction(this.scheduler, this.work);\n        this.add(action);\n        return action.schedule(state, delay);\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        this.delay = scheduler.frame + delay;\n        const { actions } = scheduler;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        return undefined;\n    }\n    _execute(state, delay) {\n        if (this.active === true) {\n            return super._execute(state, delay);\n        }\n    }\n    static sortActions(a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    }\n}\n//# sourceMappingURL=VirtualTimeScheduler.js.map"]},"metadata":{},"sourceType":"module"}