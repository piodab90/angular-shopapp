{"ast":null,"code":"import { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n  let scheduler = async;\n  let windowCreationInterval = null;\n  let maxWindowSize = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return function windowTimeOperatorFunction(source) {\n    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nclass WindowTimeOperator {\n  constructor(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n  }\n\n}\n\nclass CountedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._numberOfNextedValues = 0;\n  }\n\n  next(value) {\n    this._numberOfNextedValues++;\n    super.next(value);\n  }\n\n  get numberOfNextedValues() {\n    return this._numberOfNextedValues;\n  }\n\n}\n\nclass WindowTimeSubscriber extends Subscriber {\n  constructor(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    super(destination);\n    this.destination = destination;\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n    this.windows = [];\n    const window = this.openWindow();\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      const closeState = {\n        subscriber: this,\n        window,\n        context: null\n      };\n      const creationState = {\n        windowTimeSpan,\n        windowCreationInterval,\n        subscriber: this,\n        scheduler\n      };\n      this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      const timeSpanOnlyState = {\n        subscriber: this,\n        window,\n        windowTimeSpan\n      };\n      this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  _next(value) {\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n\n      if (!window.closed) {\n        window.next(value);\n\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window);\n        }\n      }\n    }\n  }\n\n  _error(err) {\n    const windows = this.windows;\n\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n\n    this.destination.error(err);\n  }\n\n  _complete() {\n    const windows = this.windows;\n\n    while (windows.length > 0) {\n      const window = windows.shift();\n\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n\n    this.destination.complete();\n  }\n\n  openWindow() {\n    const window = new CountedSubject();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n\n  closeWindow(window) {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n\n}\n\nfunction dispatchWindowTimeSpanOnly(state) {\n  const {\n    subscriber,\n    windowTimeSpan,\n    window\n  } = state;\n\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation(state) {\n  const {\n    windowTimeSpan,\n    subscriber,\n    scheduler,\n    windowCreationInterval\n  } = state;\n  const window = subscriber.openWindow();\n  const action = this;\n  let context = {\n    action,\n    subscription: null\n  };\n  const timeSpanState = {\n    subscriber,\n    window,\n    context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose(state) {\n  const {\n    subscriber,\n    window,\n    context\n  } = state;\n\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n\n  subscriber.closeWindow(window);\n}","map":{"version":3,"sources":["../../../src/internal/operators/windowTime.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n    let scheduler = async;\n    let windowCreationInterval = null;\n    let maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nclass WindowTimeOperator {\n    constructor(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    }\n}\nclass CountedSubject extends Subject {\n    constructor() {\n        super(...arguments);\n        this._numberOfNextedValues = 0;\n    }\n    next(value) {\n        this._numberOfNextedValues++;\n        super.next(value);\n    }\n    get numberOfNextedValues() {\n        return this._numberOfNextedValues;\n    }\n}\nclass WindowTimeSubscriber extends Subscriber {\n    constructor(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        super(destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        const window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            const closeState = { subscriber: this, window, context: null };\n            const creationState = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            const timeSpanOnlyState = { subscriber: this, window, windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    _next(value) {\n        const windows = this.windows;\n        const len = windows.length;\n        for (let i = 0; i < len; i++) {\n            const window = windows[i];\n            if (!window.closed) {\n                window.next(value);\n                if (window.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window);\n                }\n            }\n        }\n    }\n    _error(err) {\n        const windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    }\n    _complete() {\n        const windows = this.windows;\n        while (windows.length > 0) {\n            const window = windows.shift();\n            if (!window.closed) {\n                window.complete();\n            }\n        }\n        this.destination.complete();\n    }\n    openWindow() {\n        const window = new CountedSubject();\n        this.windows.push(window);\n        const destination = this.destination;\n        destination.next(window);\n        return window;\n    }\n    closeWindow(window) {\n        window.complete();\n        const windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    }\n}\nfunction dispatchWindowTimeSpanOnly(state) {\n    const { subscriber, windowTimeSpan, window } = state;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n    const window = subscriber.openWindow();\n    const action = this;\n    let context = { action, subscription: null };\n    const timeSpanState = { subscriber, window, context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    const { subscriber, window, context } = state;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map"]},"metadata":{},"sourceType":"module"}