{"ast":null,"code":"import { Subscriber } from '../Subscriber';\nexport function takeWhile(predicate, inclusive = false) {\n  return source => source.lift(new TakeWhileOperator(predicate, inclusive));\n}\n\nclass TakeWhileOperator {\n  constructor(predicate, inclusive) {\n    this.predicate = predicate;\n    this.inclusive = inclusive;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n  }\n\n}\n\nclass TakeWhileSubscriber extends Subscriber {\n  constructor(destination, predicate, inclusive) {\n    super(destination);\n    this.predicate = predicate;\n    this.inclusive = inclusive;\n    this.index = 0;\n  }\n\n  _next(value) {\n    const destination = this.destination;\n    let result;\n\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    this.nextOrComplete(value, result);\n  }\n\n  nextOrComplete(value, predicateResult) {\n    const destination = this.destination;\n\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      if (this.inclusive) {\n        destination.next(value);\n      }\n\n      destination.complete();\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/internal/operators/takeWhile.ts"],"names":[],"mappings":"AAEA,SAAS,UAAT,QAA2B,eAA3B;AAmDA,OAAM,SAAU,SAAV,CACF,SADE,EAEF,SAAS,GAAG,KAFV,EAEe;AACnB,SAAQ,MAAD,IACI,MAAM,CAAC,IAAP,CAAY,IAAI,iBAAJ,CAAsB,SAAtB,EAAiC,SAAjC,CAAZ,CADX;AAED;;AAED,MAAM,iBAAN,CAAuB;AACrB,EAAA,WAAA,CACY,SADZ,EAEY,SAFZ,EAE8B;AADlB,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,SAAA,GAAA,SAAA;AAAsB;;AAElC,EAAA,IAAI,CAAC,UAAD,EAA4B,MAA5B,EAAuC;AACzC,WAAO,MAAM,CAAC,SAAP,CACH,IAAI,mBAAJ,CAAwB,UAAxB,EAAoC,KAAK,SAAzC,EAAoD,KAAK,SAAzD,CADG,CAAP;AAED;;AARoB;;AAgBvB,MAAM,mBAAN,SAAqC,UAArC,CAAkD;AAGhD,EAAA,WAAA,CACI,WADJ,EAEY,SAFZ,EAGY,SAHZ,EAG8B;AAC5B,UAAM,WAAN;AAFU,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,SAAA,GAAA,SAAA;AALJ,SAAA,KAAA,GAAgB,CAAhB;AAOP;;AAES,EAAA,KAAK,CAAC,KAAD,EAAS;AACtB,UAAM,WAAW,GAAG,KAAK,WAAzB;AACA,QAAI,MAAJ;;AACA,QAAI;AACF,MAAA,MAAM,GAAG,KAAK,SAAL,CAAe,KAAf,EAAsB,KAAK,KAAL,EAAtB,CAAT;AACD,KAFD,CAEE,OAAO,GAAP,EAAY;AACZ,MAAA,WAAW,CAAC,KAAZ,CAAkB,GAAlB;AACA;AACD;;AACD,SAAK,cAAL,CAAoB,KAApB,EAA2B,MAA3B;AACD;;AAEO,EAAA,cAAc,CAAC,KAAD,EAAW,eAAX,EAAmC;AACvD,UAAM,WAAW,GAAG,KAAK,WAAzB;;AACA,QAAI,OAAO,CAAC,eAAD,CAAX,EAA8B;AAC5B,MAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;AACD,KAFD,MAEO;AACL,UAAI,KAAK,SAAT,EAAoB;AAClB,QAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;AACD;;AACD,MAAA,WAAW,CAAC,QAAZ;AACD;AACF;;AAhC+C","sourcesContent":["import { Subscriber } from '../Subscriber';\nexport function takeWhile(predicate, inclusive = false) {\n    return (source) => source.lift(new TakeWhileOperator(predicate, inclusive));\n}\nclass TakeWhileOperator {\n    constructor(predicate, inclusive) {\n        this.predicate = predicate;\n        this.inclusive = inclusive;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n    }\n}\nclass TakeWhileSubscriber extends Subscriber {\n    constructor(destination, predicate, inclusive) {\n        super(destination);\n        this.predicate = predicate;\n        this.inclusive = inclusive;\n        this.index = 0;\n    }\n    _next(value) {\n        const destination = this.destination;\n        let result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    }\n    nextOrComplete(value, predicateResult) {\n        const destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            if (this.inclusive) {\n                destination.next(value);\n            }\n            destination.complete();\n        }\n    }\n}\n//# sourceMappingURL=takeWhile.js.map"]},"metadata":{},"sourceType":"module"}