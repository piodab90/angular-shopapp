{"ast":null,"code":"import { canReportError } from './util/canReportError';\nimport { toSubscriber } from './util/toSubscriber';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nexport class Observable {\n  constructor(subscribe) {\n    this._isScalar = false;\n\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  lift(operator) {\n    const observable = new Observable();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext, error, complete) {\n    const {\n      operator\n    } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      sink.add(operator.call(sink, this.source));\n    } else {\n      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  _trySubscribe(sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  }\n\n  forEach(next, promiseCtor) {\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor((resolve, reject) => {\n      let subscription;\n      subscription = this.subscribe(value => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    });\n  }\n\n  _subscribe(subscriber) {\n    const {\n      source\n    } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  [Symbol_observable]() {\n    return this;\n  }\n\n  pipe(...operations) {\n    if (operations.length === 0) {\n      return this;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  toPromise(promiseCtor) {\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor((resolve, reject) => {\n      let value;\n      this.subscribe(x => value = x, err => reject(err), () => resolve(value));\n    });\n  }\n\n}\n\nObservable.create = subscribe => {\n  return new Observable(subscribe);\n};\n\nfunction getPromiseCtor(promiseCtor) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}","map":{"version":3,"sources":["../../src/internal/Observable.ts"],"names":[],"mappings":"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","sourcesContent":["import { canReportError } from './util/canReportError';\nimport { toSubscriber } from './util/toSubscriber';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nexport class Observable {\n    constructor(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    lift(operator) {\n        const observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n    subscribe(observerOrNext, error, complete) {\n        const { operator } = this;\n        const sink = toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            sink.add(operator.call(sink, this.source));\n        }\n        else {\n            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n                this._subscribe(sink) :\n                this._trySubscribe(sink));\n        }\n        if (config.useDeprecatedSynchronousErrorHandling) {\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n        }\n        return sink;\n    }\n    _trySubscribe(sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                sink.syncErrorThrown = true;\n                sink.syncErrorValue = err;\n            }\n            if (canReportError(sink)) {\n                sink.error(err);\n            }\n            else {\n                console.warn(err);\n            }\n        }\n    }\n    forEach(next, promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            let subscription;\n            subscription = this.subscribe((value) => {\n                try {\n                    next(value);\n                }\n                catch (err) {\n                    reject(err);\n                    if (subscription) {\n                        subscription.unsubscribe();\n                    }\n                }\n            }, reject, resolve);\n        });\n    }\n    _subscribe(subscriber) {\n        const { source } = this;\n        return source && source.subscribe(subscriber);\n    }\n    [Symbol_observable]() {\n        return this;\n    }\n    pipe(...operations) {\n        if (operations.length === 0) {\n            return this;\n        }\n        return pipeFromArray(operations)(this);\n    }\n    toPromise(promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            let value;\n            this.subscribe((x) => value = x, (err) => reject(err), () => resolve(value));\n        });\n    }\n}\nObservable.create = (subscribe) => {\n    return new Observable(subscribe);\n};\nfunction getPromiseCtor(promiseCtor) {\n    if (!promiseCtor) {\n        promiseCtor = config.Promise || Promise;\n    }\n    if (!promiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return promiseCtor;\n}\n//# sourceMappingURL=Observable.js.map"]},"metadata":{},"sourceType":"module"}